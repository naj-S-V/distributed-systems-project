apiVersion: v1
kind: Namespace
metadata:
  name: test
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: image-watcher-sa
  namespace: test
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: image-watcher-role
  namespace: test
rules:
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["get", "list", "patch", "update"]
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["list", "get"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: image-watcher-rb
  namespace: test
subjects:
  - kind: ServiceAccount
    name: image-watcher-sa
    namespace: test
roleRef:
  kind: Role
  name: image-watcher-role
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: image-watcher-script
  namespace: test
data:
  watch.sh: |
    #!/usr/bin/env sh
    set -euf

    : "${DOCKERHUB_OWNER:?missing}"
    : "${DOCKERHUB_REPO:?missing}"
    : "${DEPLOYMENT_NAME:?missing}"
    : "${CONTAINER_NAME:?missing}"
    : "${NAMESPACE:?missing}"

    REPO_PATH="${DOCKERHUB_OWNER}/${DOCKERHUB_REPO}"

    get_token() {
      if [ -n "${DOCKERHUB_USERNAME:-}" ] && [ -n "${DOCKERHUB_PASSWORD:-}" ]; then
        curl -fsSL "https://auth.docker.io/token?service=registry.docker.io&scope=repository:${REPO_PATH}:pull" \
          -u "${DOCKERHUB_USERNAME}:${DOCKERHUB_PASSWORD}" | jq -r '.token'
      else
        curl -fsSL "https://auth.docker.io/token?service=registry.docker.io&scope=repository:${REPO_PATH}:pull" \
          | jq -r '.token'
      fi
    }

    # MODIFIED: Look for 'build-123' style tags
    get_latest_build_tag() {
      TOKEN="$(get_token)"
      # 1. Get all tags
      # 2. Grep for 'build-' followed by numbers
      # 3. Sort on the 2nd field (k2), using '-' as delimiter (t-), numerically (n), reversed (r)
      # 4. Grab the top one
      curl -fsSL -H "Accept: application/json" \
        -H "Authorization: Bearer ${TOKEN}" \
        "https://registry-1.docker.io/v2/${REPO_PATH}/tags/list" \
        | jq -r '.tags[]' | grep -E '^build-[0-9]+$' | sort -t- -k2 -nr | head -n 1
    }

    # MODIFIED: Default to 'build-0' for a common baseline
    get_current_tag_from_annotation() {
      kubectl -n "${NAMESPACE}" get deploy "${DEPLOYMENT_NAME}" \
        -o jsonpath='{.metadata.annotations.imageVersion}' 2>/dev/null || echo "build-0"
    }

    update_deployment() {
      NEW_TAG="$1" # e.g., "build-124"
      NEW_IMAGE="${REPO_PATH}:${NEW_TAG}"

      echo "[watcher] Patching deployment image to ${NEW_IMAGE}"
      
      # 1. Patch the deployment's container image (your JSON patch was correct)
      kubectl -n "${NAMESPACE}" patch deploy "${DEPLOYMENT_NAME}" \
        --type='json' \
        -p="[{\"op\": \"replace\", \"path\": \"/spec/template/spec/containers(name==${CONTAINER_NAME})/image\", \"value\": \"${NEW_IMAGE}\"}]"

      # 2. Annotate the deployment with the new *full tag*
      kubectl -n "${NAMESPACE}" annotate deploy "${DEPLOYMENT_NAME}" \
        imageVersion="${NEW_TAG}" --overwrite

      echo "[watcher] Waiting for rollout to complete..."
      kubectl -n "${NAMESPACE}" rollout status deploy "${DEPLOYMENT_NAME}" --timeout=180s
    }

    echo "[watcher] Checking for new 'build-' tags on ${REPO_PATH} for ${NAMESPACE}/${DEPLOYMENT_NAME}"

    LATEST_REMOTE_TAG="$(get_latest_build_tag || true)"
    if [ -z "${LATEST_REMOTE_TAG}" ]; then
      echo "[watcher] Could not find any remote 'build-' tags."
      exit 0
    fi

    CURRENT_LOCAL_TAG="$(get_current_tag_from_annotation || true)"

    echo "[watcher] Remote latest tag: ${LATEST_REMOTE_TAG}"
    echo "[watcher] Current tag:       ${CURRENT_LOCAL_TAG}"

    # MODIFIED: Extract numbers for comparison
    LATEST_REMOTE_NUM=$(echo "${LATEST_REMOTE_TAG}" | cut -d'-' -f2)
    CURRENT_LOCAL_NUM=$(echo "${CURRENT_LOCAL_TAG}" | cut -d'-' -f2)

    # Use 'gt' (greater than) for numeric comparison
    if [ "${LATEST_REMOTE_NUM}" -gt "${CURRENT_LOCAL_NUM}" ]; then
      echo "[watcher] New version found. Updating deployment..."
      update_deployment "${LATEST_REMOTE_TAG}"
    else
      echo "[watcher] Up-to-date. Nothing to do."
    fi
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: image-watcher
  namespace: test
spec:
  schedule: "* * * * *"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 1
  failedJobsHistoryLimit: 2
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: image-watcher-sa
          restartPolicy: OnFailure
          containers:
            - name: watcher
              image: alpine:3.20
              imagePullPolicy: IfNotPresent
              env:
                - name: DOCKERHUB_OWNER
                  value: "najsv98"
                - name: DOCKERHUB_REPO
                  value: "scalable-app"
                - name: DEPLOYMENT_NAME
                  value: "scalable-app"
                - name: CONTAINER_NAME # <-- CRITICAL. Must match the container name in your deployment.
                  value: "scalable-app"
                - name: NAMESPACE
                  value: "test"
                # Dé-commente si repo privé:
                # - name: DOCKERHUB_USERNAME
                #   valueFrom:
                #     secretKeyRef:
                #       name: dockerhub-cred
                #       key: username
                # - name: DOCKERHUB_PASSWORD
                #   valueFrom:
                #     secretKeyRef:
                #       name: dockerhub-cred
                #       key: password
              volumeMounts:
                - name: script
                  mountPath: /opt/script
              command:
                - /bin/sh
                - -c
                - |
                  set -e
                  # Add 'jq' for JSON parsing
                  apk add --no-cache curl bash ca-certificates jq >/dev/null
                  
                  # Installe kubectl
                  KUBECTL_VER=$(curl -fsSL https://storage.googleapis.com/kubernetes-release/release/stable.txt)
                  curl -fsSL -o /usr/local/bin/kubectl https://storage.googleapis.com/kubernetes-release/release/${KUBECTL_VER}/bin/linux/amd64/kubectl
                  chmod +x /usr/local/bin/kubectl
                  
                  # This chmod is redundant if defaultMode is 0755, but safe
                  /opt/script/watch.sh
          volumes:
            - name: script
              configMap:
                name: image-watcher-script
                defaultMode: 0755