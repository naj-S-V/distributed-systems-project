apiVersion: v1
kind: Namespace
metadata:
  name: test
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: image-watcher-sa
  namespace: test
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: image-watcher-role
  namespace: test
rules:
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["get", "list", "patch", "update"]
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["list", "get"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: image-watcher-rb
  namespace: test
subjects:
  - kind: ServiceAccount
    name: image-watcher-sa
    namespace: test
roleRef:
  kind: Role
  name: image-watcher-role
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: image-watcher-script
  namespace: test
data:
  watch.sh: |
    #!/usr/bin/env sh
    set -euf

    : "${DOCKERHUB_OWNER:?missing}"
    : "${DOCKERHUB_REPO:?missing}"
    : "${DEPLOYMENT_NAME:?missing}"
    : "${CONTAINER_NAME:?missing}" # This is now required
    : "${NAMESPACE:?missing}"

    REPO_PATH="${DOCKERHUB_OWNER}/${DOCKERHUB_REPO}"
    # Note: IMAGE_TAG env var is no longer used, as we search for the tag.

    get_token() {
      if [ -n "${DOCKERHUB_USERNAME:-}" ] && [ -n "${DOCKERHUB_PASSWORD:-}" ]; then
        curl -fsSL "https://auth.docker.io/token?service=registry.docker.io&scope=repository:${REPO_PATH}:pull" \
          -u "${DOCKERHUB_USERNAME}:${DOCKERHUB_PASSWORD}" | jq -r '.token'
      else
        curl -fsSL "https://auth.docker.io/token?service=registry.docker.io&scope=repository:${REPO_PATH}:pull" \
          | jq -r '.token'
      fi
    }

    # NEW FUNCTION
    get_latest_numeric_tag() {
      TOKEN="$(get_token)"
      # Get all tags, filter for numbers-only, sort numerically (reverse), pick the top one.
      # This does NOT handle pagination. If you have >100 tags, this will fail.
      curl -fsSL -H "Accept: application/json" \
        -H "Authorization: Bearer ${TOKEN}" \
        "https://registry-1.docker.io/v2/${REPO_PATH}/tags/list" \
        | jq -r '.tags[]' | grep -E '^[0-9]+$' | sort -nr | head -n 1
    }

    get_current_version() {
      # Get the version we stored, default to "0" if it's not set
      kubectl -n "${NAMESPACE}" get deploy "${DEPLOYMENT_NAME}" \
        -o jsonpath='{.metadata.annotations.imageVersion}' 2>/dev/null || echo "0"
    }

    # MODIFIED FUNCTION
    update_deployment() {
      NEW_VERSION="$1"
      NEW_IMAGE="${REPO_PATH}:${NEW_VERSION}"

      echo "[watcher] Patching deployment image to ${NEW_IMAGE}"
      
      # 1. Patch the deployment's container image directly
      # This uses CONTAINER_NAME to target the right container in the pod
      kubectl -n "${NAMESPACE}" patch deploy "${DEPLOYMENT_NAME}" \
        --type='json' \
        -p="[{\"op\": \"replace\", \"path\": \"/spec/template/spec/containers(name==${CONTAINER_NAME})/image\", \"value\": \"${NEW_IMAGE}\"}]"

      # 2. Annotate the deployment with the new version so we don't re-deploy
      kubectl -n "${NAMESPACE}" annotate deploy "${DEPLOYMENT_NAME}" \
        imageVersion="${NEW_VERSION}" --overwrite

      # 3. Wait for the rollout to complete (this is good practice)
      echo "[watcher] Waiting for rollout to complete..."
      kubectl -n "${NAMESPACE}" rollout status deploy "${DEPLOYMENT_NAME}" --timeout=180s
    }

    echo "[watcher] Checking for new numeric tags on ${REPO_PATH} for ${NAMESPACE}/${DEPLOYMENT_NAME}"

    LATEST_REMOTE_TAG="$(get_latest_numeric_tag || true)"
    if [ -z "${LATEST_REMOTE_TAG}" ]; then
      echo "[watcher] Could not find any remote numeric tags."
      exit 0
    fi

    CURRENT_LOCAL_VERSION="$(get_current_version || true)"

    echo "[watcher] Remote latest version: ${LATEST_REMOTE_TAG}"
    echo "[watcher] Current version:       ${CURRENT_LOCAL_VERSION}"

    # Use 'gt' (greater than) for numeric comparison
    if [ "${LATEST_REMOTE_TAG}" -gt "${CURRENT_LOCAL_VERSION}" ]; then
      echo "[watcher] New version found. Updating deployment..."
      update_deployment "${LATEST_REMOTE_TAG}"
    else
      echo "[watcher] Up-to-date. Nothing to do."
    fi
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: image-watcher
  namespace: test
spec:
  schedule: "* * * * *"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 1
  failedJobsHistoryLimit: 2
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: image-watcher-sa
          restartPolicy: OnFailure
          containers:
            - name: watcher
              image: alpine:3.20
              imagePullPolicy: IfNotPresent
              env:
                - name: DOCKERHUB_OWNER
                  value: "najsv98"
                - name: DOCKERHUB_REPO
                  value: "scalable-app"
                - name: DEPLOYMENT_NAME
                  value: "scalable-app"
                - name: CONTAINER_NAME # <-- CRITICAL. Must match the container name in your deployment.
                  value: "scalable-app"
                - name: NAMESPACE
                  value: "test"
                # Dé-commente si repo privé:
                # - name: DOCKERHUB_USERNAME
                #   valueFrom:
                #     secretKeyRef:
                #       name: dockerhub-cred
                #       key: username
                # - name: DOCKERHUB_PASSWORD
                #   valueFrom:
                #     secretKeyRef:
                #       name: dockerhub-cred
                #       key: password
              volumeMounts:
                - name: script
                  mountPath: /opt/script
              command:
                - /bin/sh
                - -c
                - |
                  set -e
                  # Add 'jq' for JSON parsing
                  apk add --no-cache curl bash ca-certificates jq >/dev/null
                  
                  # Installe kubectl
                  KUBECTL_VER=$(curl -fsSL https://storage.googleapis.com/kubernetes-release/release/stable.txt)
                  curl -fsSL -o /usr/local/bin/kubectl https://storage.googleapis.com/kubernetes-release/release/${KUBECTL_VER}/bin/linux/amd64/kubectl
                  chmod +x /usr/local/bin/kubectl
                  
                  # This chmod is redundant if defaultMode is 0755, but safe
                  chmod +x /opt/script/watch.sh
                  /opt/script/watch.sh
          volumes:
            - name: script
              configMap:
                name: image-watcher-script
                defaultMode: 0755